Решили использовать cdm-8, так как при Гарвардской архитектуре его памяти должно было хватить, расширение только программной части на cdm-8e было не очень актуально, а cdm-16 показалась ещё не очень готовой.

Первым делом было составлено ТЗ с некоторыми усложнениями:
- Увеличенное поле
- Бесконечное поле
- Изменение стандартных условий выживания и жизни клеток

Первым сделанным элементом стал видеобуффер. Основанный на схеме из базовой документации к проекту, он претерпел несколько изменений, самое главное из которых, добавление отдельного интерфейса для получения на основании координат Y и X выбранной строки матрицы целиком, её байт, включающего X и непосредственно бита X. Эти выходные интерфейсы пригодятся сразу в нескольких местах проекта.

Контроллера с буфером и матрицей обнаружилась проблема - нулевой угол сверху справа, а не сверху слева, как было бы привычно программистам и не тем более снизу слева, как было бы привычно обычным людям. Решение простое - преворачивание строки битов в обратную сторону. 

Для ввода четырёхбайтовой строки решили использовать 5 регистров, одного из которых на самом деле не существует. При адресации процессора в его ячейку фиксируется только тот факт, `ld` или `st` была отправлена инструкция. В зависимости от неё в 4 реальных регистра будут загружаться данные из буфера или наоборот.

# Блинкер
Для изменения состояния ячейки из для мигающей клетки как указателя на матрице использовался элемент интвертер бита, принимающий все строки из видеобуфера, координаты Y и X, а также вход `switch`, который определял бы, нужно ли менять бит. Кроме 32 выходов для матрицы был отдельный выход, который возвращал конкретно нужную нам в данный момент строку битов.

Так как цель использования блинкера двойная, сначала мы попытались поставить их 2 штуки. Результат был... Жутким

*Вставить сюда картинку двух блинкеров*

После этого было найдено более элегантное решение: на вход `switch` подаётся сигнал `clock`, а его инверсия служит триггером для регистра на выходе изменяемой строки. За счёт такой комбинации в регистр всегда записывалась строка с изменённым битом. При необходимости её можно было бы легко переписать в видеобуффер.

# Ассемблерная часть
Сначала планировалось, что строки матрицы будут запрашиваться процессором из буфера по необходимости, но для ускорения работы было решено сохранять в оперативную память всё текущее поле, а потом отправлять в буфер строки нового состояния поля по одной.

Вторым (потенциальным) оптимизационным решением стало сохранение ячеек поля, с которыми сейчас работаем, и их адресов в ячейки `0x10`-`0x18` и `0x20`-`0x28` соответственно. Это позволит:
1. Подпрограмме расчёта нового состояния байта работать с универсальным интерфейсом без необходимости сдвигаться по сложным правилам
2. Быстро перезаписывать рабочие ячейки зацикленным на поле адресов инкриментом

Условия выживания преобразуются в условия смерти для универсальности проверки (просто выбираем байт либо условий жизни, либо смерти, а дальше код идентичен)

**ПО АБСОЛЮТНО НЕВЕДОМОЙ МАГИЧЕСКОЙ ПРИЧИНЕ УСЛОВИЯ СРАВНЕНИЯ ДЛЯ БЕЗЗНАКОВЫХ ЧИСЕЛ КОРРЕКТНО НЕ РАБОТАЛИ!!! Ух... Сколько же крови выпил у меня этот момент...**

Для небольшой оптимизации по памяти поле записывается с последнего ряда, а в циклах и ифах tst часто опускается, так как инкримент/декремент идёт сразу перед проверкой, а значит уже влияет на CVZN регистр

В связи с недостатком памяти для инструкций мигрировали CdM-8e. Механизм констант через asect'ы стал ломаться на этапе компиляции, что было исправлено небольшим костылём: код программы начинается с ячейки 0x100, до которой идёт холостой инкремент