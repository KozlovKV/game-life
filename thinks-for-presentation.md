Решили использовать cdm-8, так как при Гарвардской архитектуре его памяти должно было хватить, расширение только программной части на cdm-8e было не очень актуально, а cdm-16 показалась ещё не очень готовой.

Первым делом было составлено ТЗ с некоторыми усложнениями:
- Увеличенное поле
- Бесконечное поле
- Изменение стандартных условий выживания и жизни клеток

# Logisim

Первым сделанным элементом стал видеобуффер. Основанный на схеме из базовой документации к проекту, он претерпел несколько изменений, самое главное из которых, добавление отдельного интерфейса для получения на основании координаты Y выбранной строки матрицы, которая далее направлялась в деструктор для извлечения бита с координатой X (индексом). Это было необходимо для вывода пользователю состояния элемента под курсором...

О котором сейчас и пойдёт речь: вместо джойстика мы решили использовать управление с клавиатуры, что сильно простило добавление новых команд и позволило двигаться по полю куда быстрее. Положение курсора на поле обозначается миганием, для реализации которого был создан блинкер

## Блинкер
Для изменения состояния ячейки из для мигающей клетки как указателя на матрице использовался элемент интвертер бита, принимающий все строки из видеобуфера, координаты Y и X, а также вход `switch`, который определял бы, нужно ли менять бит. Кроме 32 выходов для матрицы был отдельный выход, который возвращал конкретно нужную нам в данный момент строку битов.

Так как цель использования блинкера двойная, сначала мы попытались поставить их 2 штуки. Результат был... Жутким

*Вставить сюда картинку двух блинкеров*

После этого было найдено более элегантное решение: на вход `switch` подаётся сигнал `clock`, а его инверсия служит триггером для регистра на выходе изменяемой строки. За счёт такой комбинации в регистр всегда записывалась строка с изменённым битом. При необходимости её можно было бы легко переписать в видеобуффер.

---

Для вывода строк в матрицу использовался реверсёр битовой строки, чтобы располагались координаты в привычном программистам виде (точка отсчёта - верхний левый угол)

Для общения процессора с буфером решили использовать 5 регистров, одного из которых на самом деле не существует. При адресации процессора в его ячейку фиксируется только тот факт, `ld` или `st` была отправлена инструкция. В зависимости от неё в 4 реальных регистра будут загружаться данные из буфера или отправляться из регистров в буфер, собираясь в строку.



# Ассемблерная часть
Сначала планировалось, что строки матрицы будут запрашиваться процессором из буфера по необходимости, но для ускорения работы было решено сохранять в оперативную память всё текущее поле, а потом отправлять в буфер строки нового состояния поля по одной.

Вторым (потенциальным) оптимизационным решением стало сохранение ячеек поля, с которыми сейчас работаем, и их адресов в ячейки `0x10`-`0x18` и `0x20`-`0x28` соответственно. Это позволит:
1. Подпрограмме расчёта нового состояния байта работать с универсальным интерфейсом без необходимости сдвигаться по сложным правилам
2. Быстро перезаписывать рабочие ячейки зацикленным на поле адресов инкриментом

Условия выживания преобразуются в условия смерти для универсальности проверки (просто выбираем байт либо условий жизни, либо смерти, а дальше код идентичен)

**ПО АБСОЛЮТНО НЕВЕДОМОЙ МАГИЧЕСКОЙ ПРИЧИНЕ УСЛОВИЯ СРАВНЕНИЯ ДЛЯ БЕЗЗНАКОВЫХ ЧИСЕЛ КОРРЕКТНО НЕ РАБОТАЛИ!!! Ух... Сколько же крови выпил у меня этот момент...**

Для небольшой оптимизации по памяти поле записывается с последнего ряда, а в циклах и ифах tst часто опускается, так как инкримент/декремент идёт сразу перед проверкой, а значит уже влияет на CVZN регистр

В связи с недостатком памяти для инструкций мигрировали CdM-8e. 

После реализации основной части кода процессора стало очевидно, что оптимизаций, описанных выше, не хватает - подсчёт всего поля занимал 15-30 минут.

Простейшее решение - игнорировать такие байты, для которых все байты окружения равны нулю - не дало ощутимого результата.

Следующей мыслью было свести все байты слева и справа от центрального к одному биту, отражающему их 7-й и 0-й биты соответственно. Это сильно улучшило бы работу с крайними чейками, но никак не помогло бы при обработке битов нужного байта 1-6. В этот момент возникла новая идея - использовать область в памяти размера 10*3 для записи в каждой ячейке всего лишь по одному биту, то есть распластать всё значимое окружение считаемого байта и его самого на биты по плоскости. Это позволило бы:
1. Сделать универсальную обработку для всех битов целевого байта (на данный момент с реализацией окружения из 9-ти байт приходилось писать отдельный необычный и неприятный код для 7-го и 0-го битов)
2. Обращаться к нужному нам байту за константу, не зависящую от индекса бита

*Потенциально, это должна была быть очень крутая оптимизация*