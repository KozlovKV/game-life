# Уже реализованный функционал смотри в [документации](./docs.md)

# Useful Links
- [Base technical project](https://docs.google.com/document/d/1kJ8-gw4B7FSjKWGDvSniI5XdDR_gwaIY53QfoiJkYJ4/edit)
- [CdM8e](https://github.com/leadpogrommer/Cdm8-asm)
- [cdm-devkit](https://github.com/cdm-processors/cdm-devkit)

# Technical project
Идеальный вариант соотношения программной и аппаратной части - 1/1

**Разумеется, код и схемы должны быть красивыми и понятными!**

**Избегать спагетти-проводов, не злоупотреблять туннелями (подробно их подписывать) и разделять на отдельные блоки только совсем уж большие компоненты (здесь не всегда нужен принцип DRY)**

## Сопроводиетльное письмо
Очень желательно изобразить блок-схему

Рисунки сопровождать подписями

## Презентация
Не рекламная, а для инженеров, но без сверх-больших подробностей.

## Документация
Документация должна содержать:
- Общий обзор проекта
- Как играть
- Обзор программной части
- Обзор аппаратной части

В последних пунктах подразумевается подробное описание: какие используются регистры, как работаем с памятью, какие провода за что отвечают.

## Правила игры
Поле с живыми и неживыми клетками, в которой клетки каждое поколение меняется.

Для расчёта следующего поколения у каждой клетки считаются разные типы соседей:
- Могут считать все окружающие соседи (8 клеток)
- Могут считаться соседи с полноценной границей (4 клетки)

Набор правил описывается комбинацией `B[x...x] / S[y...y]`, где :
- `[x...x]` - набор значений соседей, при наличии которых неживая клетка становится живой
- `[y...y]` - набор значений соседей, при которых клетка продолжает жить
- При всех иных значениях клетка умирает или остаётся неживой

**Стандартные правила: считаются окружающие клетки и поколения рассчитываются по правилу `B3 / S23`**

## Технические требования
- Матрица 32*32
- Буфер для хранения текущего поколения, передающий данные одновременно на матрицу и в процессор
- Замкнутое поле при расчётах
- Первоначальная настройка
  - Изменение правил `B`, `S` при помощи инпутов по 8 бит
  - Позиция указателя на поле изменяется по восьми направлениями при нажатии на определённые клавиши (Планируем использовать NumBlock)
  - Позиция указателя на матрице отображается мигающим пикселем
    - Состояние клетки под указателем будет показываться на отдельном LED-индикатора
  - Состояние клетки, на которую указывает джойстик, будет меняться кнопкой
  - Кнопка сброса поля (фактически, сброса работы всего процессора. Думаю, это не самая лучшая затея, хотя попробовать можно)

## Что будет делать ассемблер
Дожидается начала симуляции жизни, после чего загружает условия игры и всё поле из буфера в свою память. Когда прорабатывает новую строку, отправляет её на буфер через 4 IO регистра.

Формальный цикл:
- Ждём начала игры
- Считываем настройки
- Бесконечный цикл:
  - Считали всё поле
  - Проходимся по всем точкам:
    - Считаем количество живых соседей
    - Если выбранная клетка пуста:
      - Проверяем условия рождения. Если выполнены, то задаём бит как единицу
    - Иначе:
      - Проверяем условия жизни. Если не выполнены, обнуляем бит
  - Когда таким образом был сохранён целый байт, сохраняем его во временную строку
  - Когда было сохранено 4 байта, отправляем их через I/O регистры на матрицу

Из этого алгоритма можем выделить следующие подпрограммы:
- Запись целого поля в память
- Отправка строки в видеобуффер
- Циклический инкремент
- Циклический декремент
- Получение конкретного бита из байта
- Установка нужного значения конкретного бита в байте (без влияния на остальные)
- Подсчёт кол-ва единичный битов вокруг
- Определение нового состояния текущего бита на основании идущих ранее подпрограмм

### Внутренние данные
- Состояние игры (0 или 1) - `0x00`
- Байт условий рождения - `0x01`
- Байт условий смерти - `0x02`
- Всё поле будет располагаться в 128-ми ячейках памяти `0x70`-`0xef`
- Все байты вокруг того, с которым сейчас работаем - `0x10`-`0x18`
  - `0x10` - верхний левый относительно текущего
  - `0x11` - верхний относительно текущего
  - `0x12` - верхний правый относительно текущего
  - `0x13` - левый относительно текущего
  - `0x14` - текущий байт
  - `0x15` - правый относительно текущего
  - `0x16` - нижний левый относительно текущего
  - `0x17` - нижний относительно текущего
  - `0x18` - нижний правый относительно текущего

Начальная позиция стэка - `0x70`

### Ввод-вывод
IO регистры будут перехватывать адреса ОЗУ `0xf0`-`0xff`. Распределение будет следующим:
- `0xf0` - READ ONLY - состояние игры. `0` - настройка. `1` - симуляция
- `0xf1` - READ ONLY - количество клеток для оживления (битовый массив, где `i`-й бит говорит о `i+1` количестве клеток для выполнения условия)
- `0xf2` - READ ONLY - количество клеток, при которых клетка умрёт (битовый массив, где `i`-й бит говорит о `i+1` количестве клеток для выполнения условия)
- `0xf3` - WRITE ONLY - координата Y строки, с которой сейчас работаем
- `0xf4` - WRITE ONLY - координата X (*скорее всего не будет нужен*)
- `0xf5` - PSEUDO READ / PSEUDO WRITE - бит бит направления строки из следующих четырёх регистров. 
  - Когда сюда отправляется запрос на запись, значение строки из последующих 4 байтов отправляется записывается в строку `Y` видеобуфера. 
  - Когда отправляется запрос на чтение, выгружает в следующие 4 регистра строку по индексу `Y`
- `0xf6`-`0xf9` - READ / WRITE - 4 регистра для выбранной строки в порядке little-endian (при запросе на чтение будет загружаться из буфера, при запросе на запись будет отправлять значение во временное хранилище)
- `0xfa` - WRITE ONLY - отображает номер процесса, которым сейчас занят процессор. Используется для отладки

### Псевдокод
*Всё остальное уже реализовано (появится в документации... Когда-нибудь), так что здесь останутся только те части, что отвечают за расчёт нового байта:*

```python
macro cycledInc/2: 
  # $1 - регистр, которы надо циклически инкриментировать
  # $2 - место для временных значений
  $1++
  $2 = 0b00000111
  $1 = $1 & $2

getBit:
  # r0 - байт
  # r1 - индекс интересующего нас бита
  while r1 > 0: # Для экономии место лучше использовать do-until (держать в голове, что он исполняется, пока условие ложно!)
    r0 >>= 1 
    r1--
  r1 = 1
  r0 = r0 & r1
rts

invertBit:
  # r0 - байт
  # r1 - индекс бита, который надо инвертировать
  r2 = 1 # маска
  while r1 > 0:
    mask <<= 1 # Убедиться, что заполняется число нулями
    r1--
  r0 = r0 xor r2
rts

processBitInByte:
  # r0 - изменяемый байт (значение нужно вернуть сюда же)
  # r1 - индекс бита
  # r2 - сумма битов вокруг
  push r0
  push r1
  getBit() # Проверяем, в каком состоянии текущий бит
  if r0 == 0:
    load r0, birthConditions
  else:
    load r0, deathConditions
  move r2 to r1
  r1--
  getBit() # За счёт того, что условия хранятся в виде битовых массивов, мы легко проверяем их выполнение при помощи индексного запроса
  move r0 to r2
  pop r1
  pop r0 # Если бы не сдвинули стэк обратно тут, то пришлось бы делать это в цикле, что было бы менее оптимально по памяти
  if r2 == 1:
    invertBit()
rts

getNewByteState:
  # В эту функцию не передаётся ничего. 
  # Все данные хранятся в ячейках 0x10-0x18 (см. "Внутренние данные")
  # Вернуть новый байт надо в r0
  
  r0 = 0x14
  load r0, r0
  r1 = newByteAddr
  save r0 to r1

  # Обработка битов с 1 по 6-й
  r1 = 6 # индекс обрабатываемого бита
  while r1 > 0:
    push r1 # Сохраняем значение центрального бита
    push r1 # Дубликат нужен для быстрой работы в конце цикла
    r0 = 0x11 # Адрес обрабатываемого для подсчёта окружающих битов байта
    r1-- # Переводим бит в позицию, нужную для левого верхнего положения
    push r1
    push r1 # запихиваем в стэк дубликаты, чтобы в условии в цикле далее не пришлось вытаскивать значение из стэка и сохранять повторно
    r2 = 0 # Значение суммы
    r3 = 8 # Счётчик на декременте
    while r3 > 0:
      push r0
      load r0, r0

      getBit()
      if r0 != 0:
        r2++

      cycledInc r1 
      if r3 == 5:
        cycledInc r1
      if r3 == 6 or r3 == 4:
        pop r1
        r0 += 3
      r3--
    # Загружаем уже полученное значение
    r0 = newByteAddr
    load r0, r0
    pop r1
    processBitInByte()
    r1 = newByteAddr
    save r0 to r1
    pop r1
    r1--
  

```

## Дополнительные идеи
### Загрузка поля из файла
1. Состояние поля задаётся в текстовом файле
2. Пишется скрипт (*На Питоне?*), который будет читать текстовое поле и переводить его в тривиальный img-файл из 128 HEX-кодов
3. Файл загружается в RAM-блок в Logisim, который при нажатии кнопки начнёт его выгружать в буфер побайтово
   1. *Функционал побайтовой загрузки/выгрузки уже реализован в процессоре. Возможно имеет смысл попытаться внедрить дополнительный RAM-блок прямо туда и прописать код для его выгрузки*
      1. **Загружать текстовое представление напрямую в RAM-процессора и далее подавать сигнал на его выгрузку. После выгрузки процессор очистит память либо и вовсе будет просто писать новые данные поверх исходных**

Идея интересна и позволит очень оптимизировать процесс построения сложных конструкцию, **НО:** это будто бы отчасти противоречит концепции игры. Хотя... С чего бы это вдруг? В Майнкрафте мы же можем добавлять себе карты миров как файлы или передавать свои миры кому-то. В общем, если будет реализован весь базовый функционал, будет иметь смысл заняться и этой фишкой