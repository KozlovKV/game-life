# Уже реализованный функционал смотри в [документации](./docs.md)

# Useful Links
- [Base technical project](https://docs.google.com/document/d/1kJ8-gw4B7FSjKWGDvSniI5XdDR_gwaIY53QfoiJkYJ4/edit)
- [CdM8e](https://github.com/leadpogrommer/Cdm8-asm)
- [cdm-devkit](https://github.com/cdm-processors/cdm-devkit)

# Technical project
Идеальный вариант соотношения программной и аппаратной части - 1/1

**Разумеется, код и схемы должны быть красивыми и понятными!**

**Избегать спагетти-проводов, не злоупотреблять туннелями (подробно их подписывать) и разделять на отдельные блоки только совсем уж большие компоненты (здесь не всегда нужен принцип DRY)**

## Презентация
Не рекламная, а для инженеров, но без сверх-больших подробностей.

## Документация
Документация должна содержать:
- Общий обзор проекта
- Как играть
- Обзор программной части
- Обзор аппаратной части

В последних пунктах подразумевается подробное описание: какие используются регистры, как работаем с памятью, какие провода за что отвечают.

## Правила игры
Поле с живыми и неживыми клетками, в которой клетки каждое поколение меняется.

Для расчёта следующего поколения у каждой клетки считаются разные типы соседей:
- Могут считать все окружающие соседи (8 клеток)
- Могут считаться соседи с полноценной границей (4 клетки)

Набор правил описывается комбинацией `B[x...x] / S[y...y]`, где :
- `[x...x]` - набор значений соседей, при наличии которых неживая клетка становится живой
- `[y...y]` - набор значений соседей, при которых клетка продолжает жить
- При всех иных значениях клетка умирает или остаётся неживой

**Стандартные правила: считаются окружающие клетки и поколения рассчитываются по правилу `B3 / S23`**

## Технические требования
- Матрица 32*32
- Буфер для хранения текущего поколения, передающий данные одновременно на матрицу и в процессор
- Замкнутое поле при расчётах
- Первоначальная настройка
  - Изменение правил `B`, `S` при помощи инпутов по 8 бит
  - Позиция указателя на поле изменяется по восьми направлениями при нажатии на определённые клавиши (Планируем использовать NumBlock)
  - Позиция указателя на матрице отображается мигающим пикселем
    - Состояние клетки под указателем будет показываться на отдельном LED-индикатора
  - Состояние клетки, на которую указывает джойстик, будет меняться кнопкой
  - Кнопка сброса поля (фактически, сброса работы всего процессора. Думаю, это не самая лучшая затея, хотя попробовать можно)

## Что будет делать ассемблер
Дожидается начала симуляции жизни, после чего загружает условия игры и всё поле из буфера в свою память. Когда прорабатывает новую строку, отправляет её на буфер через 4 IO регистра.

IO регистры будут перехватывать адреса ОЗУ `0xf0`-`0xff`. Распределение будет следующим:
- `0xf0` - READ ONLY - состояние игры. `0` - настройка. `1` - симуляция
- `0xf1` - READ ONLY - количество клеток для оживления (битовый массив, где `i`-й бит говорит о `i+1` количестве клеток для выполнения условия)
- `0xf2` - READ ONLY - количество клеток для продолжения жизни (битовый массив, где `i`-й бит говорит о `i+1` количестве клеток для выполнения условия)
- `0xf3` - WRITE ONLY - координата Y строки, с которой сейчас работаем
- `0xf4` - WRITE ONLY - координата X (*скорее всего не будет нужен*)
- `0xf5` - PSEUDO READ / PSEUDO WRITE - бит бит направления строки из следующих четырёх регистров. 
  - Когда сюда отправляется запрос на запись, значение строки из последующих 4 байтов отправляется записывается в строку `Y` видеобуфера. 
  - Когда отправляется запрос на чтение, выгружает в следующие 4 регистра строку по индексу `Y`
- `0xf6`-`0xf9` - READ / WRITE - 4 регистра для выбранной строки в порядке little-endian (при запросе на чтение будет загружаться из буфера, при запросе на запись будет отправлять значение во временное хранилище)